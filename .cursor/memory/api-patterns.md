# API実装のパターンとベストプラクティス

## パーソナルプログラム関連記事の永続化パターン (2025-05-07)

### 背景と課題
パーソナルプログラム機能では、ユーザー向けに生成された番組内で紹介されたQiita記事を永続化し、後からユーザーが参照できるようにする必要があった。番組生成→ファイルアップロード→記事DB保存→プログラムDB保存という複数のステップを含むフローを設計する必要があった。

### 検討したアプローチ
1. **新規テーブル導入アプローチ**:
   - 記事とプログラムの関連性スコア、言及時間などの追加情報を格納する中間テーブルを新設する
   - メリット: より詳細な情報を保存可能
   - デメリット: スキーマ変更とマイグレーションが必要、実装工数が増加

2. **既存構造活用アプローチ**:
   - 既存のQiitaPostモデルとPersonalizedFeedProgramモデルの多対多関連を利用
   - メリット: シンプルな設計、既存コードの再利用、マイグレーション不要
   - デメリット: 保存できる情報が限定的

### 決定事項と理由
- 既存テーブル構造を活用するアプローチを採用
- 理由:
  1. ユーザー要件を満たすために追加情報（関連性スコア、言及時間など）は必須ではない
  2. HeadlineTopicProgram実装との一貫性を保持できる
  3. 実装工数を大幅に削減でき、早期リリースが可能

### 実装パターン
- **フロー順序**: 音声生成 → ファイルアップロード → 記事DB保存 → プログラムDB保存
- **エラーハンドリング**: エラー種別に特化した例外クラス階層を活用（PersonalizedProgramPersistenceError等）
- **トランザクション処理**: PrismaClientManagerを利用した一貫性のあるDB操作
- **テスト戦略**: モックを活用した単体テスト、型安全性の確保

### 学んだ教訓
1. 新規機能実装時には、まず既存のコードパターンを調査し、再利用可能な部分を特定すべき
2. ユーザー要件を厳密に精査し、過度な設計複雑化を避ける
3. モデル間の関連性（多対多など）を活用することでシンプルな実装が可能
4. TypeScriptのモックデータ作成時は特に型定義を慎重に行うべき

### 関連タスク
- 記事データ保存プロセス実装 (P1)
- 記事永続化テスト (P1)
- ユーザー記事履歴API実装 (予定)
