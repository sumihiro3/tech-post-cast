# UI/UX設計の学びと教訓

## ユーザー設定画面の実装 (2025-01-23)

### 背景と課題

TPC-101チケットでユーザーダッシュボードのユーザー設定画面を実装。当初はレイアウトコンポーネントから始める設計を提案したが、ユーザーからの指摘により既存レイアウトの活用と適切なコンポーネント分割の重要性を学んだ。

### 検討したアプローチ

1. **当初提案**: DashboardLayoutなどの新規レイアウトコンポーネント作成
2. **修正案**: 既存の`user-app.vue`レイアウト活用
3. **コンポーネント分割**: フォーム全体 vs UIセクションのみ分離

### 決定事項と理由

- **既存レイアウトの活用**: `user-app.vue`が完璧に機能しているため新規作成は不要
- **適度なコンポーネント分割**: UIコンポーネントのみ分離し、フォーム状態管理はページレベルで実装
- **emit/propsの複雑化回避**: アクションボタンをページレベルに配置し、状態管理を一元化

### 学んだ教訓

1. **既存リソースの十分な調査**: 新規実装前に既存コンポーネントの機能を詳細に確認する
2. **適切な責任分離**: UIとロジックの分離レベルを適切に設定し、過度な分割を避ける
3. **ユーザーフィードバックの価値**: 実装者の視点だけでなく、利用者の観点からの設計見直しが重要

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## Vue 3 + Nuxt 3でのコンポーネント間通信パターン (2025-01-23)

### 背景と課題

Vue 3では`emit`が戻り値を返さないため、子コンポーネントから親の非同期関数の結果を直接受け取れない問題が発生。

### 検討したアプローチ

1. **emit使用**: `@test-webhook="handleTestWebhook"`（失敗）
2. **props関数渡し**: `:on-test-webhook="handleTestWebhook"`（成功）

### 決定事項と理由

- **props経由での関数渡し**: 非同期処理の結果を確実に受け取るため
- **emit削除**: Vue 3の制約により戻り値が取得できないため

### 学んだ教訓

- **Vue 3の制約理解**: emitの戻り値制限を事前に把握する重要性
- **非同期処理パターン**: 子コンポーネントでの非同期処理結果取得にはprops関数が適している

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## Nuxt 3自動インポート機能の活用 (2025-01-23)

### 背景と課題

コンポーネントの明示的インポートでエラーが発生。Nuxt 3の自動インポート機能との競合が原因。

### 検討したアプローチ

1. **明示的インポート**: `import`文での手動インポート（失敗）
2. **自動インポート活用**: `.nuxt/components.d.ts`で生成された名前を使用（成功）

### 決定事項と理由

- **自動インポート機能の活用**: Nuxt 3の標準機能を最大限活用
- **生成された名前の使用**: `DashboardSettingsUserNameSection`など、ディレクトリ構造に基づく命名

### 学んだ教訓

- **フレームワーク機能の理解**: Nuxt 3の自動インポート機能を正しく理解し活用する
- **生成ファイルの確認**: `.nuxt/components.d.ts`で実際の生成名を確認する重要性

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## バリデーション設計のベストプラクティス (2025-01-23)

### 背景と課題

Slack Webhook URLの詳細なバリデーションが必要。単純なURL形式チェックでは不十分。

### 検討したアプローチ

1. **基本URL形式チェック**: `new URL()`のみ
2. **詳細バリデーション**: ドメイン、パス構造、ID形式まで検証

### 決定事項と理由

- **段階的バリデーション**: 空文字 → HTTPS → ドメイン → パス構造 → ID形式の順で検証
- **具体的エラーメッセージ**: ユーザーが修正しやすい詳細なメッセージ提供

### 学んだ教訓

- **段階的検証の有効性**: 複雑なバリデーションは段階的に実装し、具体的なエラーを提供
- **ユーザビリティ重視**: 技術的な正確性とユーザーの使いやすさのバランス

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

## 共通UIコンポーネントの統一化 (2024-12-19)

### 背景と課題

複数の異なるUI状態管理方法（`useSnackbar`、`useProgress`、個別コンポーネント）が混在し、以下の課題があった：

- 開発者の学習コストが高い
- 一貫性のないUI表示
- 保守性の低下
- コードの重複

### 検討したアプローチ

1. **完全置き換えアプローチ**: 既存composableを削除し、新しい統一composableを作成
   - 利点: 完全に統一されたAPI
   - 欠点: 既存の動作するコードを無駄にする、リスクが高い

2. **段階的統一アプローチ**: 既存composableを活用し、上位レイヤーで統一インターフェースを提供
   - 利点: 既存資産の活用、段階的移行、リスク最小化
   - 欠点: 一時的な複雑性

3. **別パッケージ化アプローチ**: 共通UIコンポーネントを独立したパッケージとして作成
   - 利点: 完全な分離、再利用性
   - 欠点: 依存関係の複雑化、ビルド設定の複雑化

### 決定事項と理由

段階的統一アプローチを採用し、以下の実装を行った：

```typescript
// useUIState: 統一インターフェース
export const useUIState = (): UIStateReturn => {
  const snackbar = useSnackbar(); // 既存composableを活用
  const progress = useProgress();  // 既存composableを活用

  return {
    // 統一されたAPI
    showLoading: (options) => progress.show(options),
    showSuccess: (message, options) => snackbar.showSuccess(message, options),
    // ...
  };
};
```

**選択理由:**

- 既存の動作するコード（SSR対応、Vuetify連携）を活用
- 段階的な移行により、リスクを最小化
- 開発者にとって使いやすい統一API

### 学んだ教訓

#### KEY INSIGHT: 段階的統一化パターンの有効性

- **既存資産の価値**: 動作している既存コードは貴重な資産として活用すべき
- **上位レイヤーでの統一**: 下位の実装を変更せずに、使いやすいAPIを提供可能
- **段階的アプローチ**: 一度にすべてを変更するよりも安全で効率的

#### UI状態管理のベストプラクティス

1. **グローバル状態の一元管理**: アプリケーション全体で一貫したUI状態管理
2. **共通コンポーネントの活用**: `AppSnackbar`、`AppProgress`をレイアウトに配置
3. **型安全性の確保**: 明示的な戻り値型定義とlinterエラーの完全解消

#### 開発者体験の向上

```typescript
// 統一前: 複数のcomposableを覚える必要
const snackbar = useSnackbar();
const progress = useProgress();
snackbar.showSuccess('成功');
progress.show({ text: '処理中...' });

// 統一後: 一つのAPIで完結
const ui = useUIState();
ui.showSuccess('成功');
ui.showLoading({ message: '処理中...' });
```

### 関連タスク

- TPC-101: ユーザーダッシュボードの実装
- 共通UIコンポーネントの実装と統一化

### 今後の適用可能性

- 他のUI状態（モーダル、サイドバー、トースト通知など）への拡張
- 他のアプリケーション（api-backend、line-bot）での類似パターンの適用
- アニメーションやテーマの統一化
