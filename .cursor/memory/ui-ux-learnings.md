# UI/UX設計の学びと教訓

## ユーザー設定画面の実装 (2025-01-23)

### 背景と課題

TPC-101チケットでユーザーダッシュボードのユーザー設定画面を実装。当初はレイアウトコンポーネントから始める設計を提案したが、ユーザーからの指摘により既存レイアウトの活用と適切なコンポーネント分割の重要性を学んだ。

### 検討したアプローチ

1. **当初提案**: DashboardLayoutなどの新規レイアウトコンポーネント作成
2. **修正案**: 既存の`user-app.vue`レイアウト活用
3. **コンポーネント分割**: フォーム全体 vs UIセクションのみ分離

### 決定事項と理由

- **既存レイアウトの活用**: `user-app.vue`が完璧に機能しているため新規作成は不要
- **適度なコンポーネント分割**: UIコンポーネントのみ分離し、フォーム状態管理はページレベルで実装
- **emit/propsの複雑化回避**: アクションボタンをページレベルに配置し、状態管理を一元化

### 学んだ教訓

1. **既存リソースの十分な調査**: 新規実装前に既存コンポーネントの機能を詳細に確認する
2. **適切な責任分離**: UIとロジックの分離レベルを適切に設定し、過度な分割を避ける
3. **ユーザーフィードバックの価値**: 実装者の視点だけでなく、利用者の観点からの設計見直しが重要

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## Vue 3 + Nuxt 3でのコンポーネント間通信パターン (2025-01-23)

### 背景と課題

Vue 3では`emit`が戻り値を返さないため、子コンポーネントから親の非同期関数の結果を直接受け取れない問題が発生。

### 検討したアプローチ

1. **emit使用**: `@test-webhook="handleTestWebhook"`（失敗）
2. **props関数渡し**: `:on-test-webhook="handleTestWebhook"`（成功）

### 決定事項と理由

- **props経由での関数渡し**: 非同期処理の結果を確実に受け取るため
- **emit削除**: Vue 3の制約により戻り値が取得できないため

### 学んだ教訓

- **Vue 3の制約理解**: emitの戻り値制限を事前に把握する重要性
- **非同期処理パターン**: 子コンポーネントでの非同期処理結果取得にはprops関数が適している

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## Nuxt 3自動インポート機能の活用 (2025-01-23)

### 背景と課題

コンポーネントの明示的インポートでエラーが発生。Nuxt 3の自動インポート機能との競合が原因。

### 検討したアプローチ

1. **明示的インポート**: `import`文での手動インポート（失敗）
2. **自動インポート活用**: `.nuxt/components.d.ts`で生成された名前を使用（成功）

### 決定事項と理由

- **自動インポート機能の活用**: Nuxt 3の標準機能を最大限活用
- **生成された名前の使用**: `DashboardSettingsUserNameSection`など、ディレクトリ構造に基づく命名

### 学んだ教訓

- **フレームワーク機能の理解**: Nuxt 3の自動インポート機能を正しく理解し活用する
- **生成ファイルの確認**: `.nuxt/components.d.ts`で実際の生成名を確認する重要性

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

---

## バリデーション設計のベストプラクティス (2025-01-23)

### 背景と課題

Slack Webhook URLの詳細なバリデーションが必要。単純なURL形式チェックでは不十分。

### 検討したアプローチ

1. **基本URL形式チェック**: `new URL()`のみ
2. **詳細バリデーション**: ドメイン、パス構造、ID形式まで検証

### 決定事項と理由

- **段階的バリデーション**: 空文字 → HTTPS → ドメイン → パス構造 → ID形式の順で検証
- **具体的エラーメッセージ**: ユーザーが修正しやすい詳細なメッセージ提供

### 学んだ教訓

- **段階的検証の有効性**: 複雑なバリデーションは段階的に実装し、具体的なエラーを提供
- **ユーザビリティ重視**: 技術的な正確性とユーザーの使いやすさのバランス

### 関連タスク

TPC-101 ユーザーダッシュボードの実装

## 共通UIコンポーネントの統一化 (2024-12-19)

### 背景と課題

複数の異なるUI状態管理方法（`useSnackbar`、`useProgress`、個別コンポーネント）が混在し、以下の課題があった：

- 開発者の学習コストが高い
- 一貫性のないUI表示
- 保守性の低下
- コードの重複

### 検討したアプローチ

1. **完全置き換えアプローチ**: 既存composableを削除し、新しい統一composableを作成
   - 利点: 完全に統一されたAPI
   - 欠点: 既存の動作するコードを無駄にする、リスクが高い

2. **段階的統一アプローチ**: 既存composableを活用し、上位レイヤーで統一インターフェースを提供
   - 利点: 既存資産の活用、段階的移行、リスク最小化
   - 欠点: 一時的な複雑性

3. **別パッケージ化アプローチ**: 共通UIコンポーネントを独立したパッケージとして作成
   - 利点: 完全な分離、再利用性
   - 欠点: 依存関係の複雑化、ビルド設定の複雑化

### 決定事項と理由

段階的統一アプローチを採用し、以下の実装を行った：

```typescript
// useUIState: 統一インターフェース
export const useUIState = (): UIStateReturn => {
  const snackbar = useSnackbar(); // 既存composableを活用
  const progress = useProgress();  // 既存composableを活用

  return {
    // 統一されたAPI
    showLoading: (options) => progress.show(options),
    showSuccess: (message, options) => snackbar.showSuccess(message, options),
    // ...
  };
};
```

**選択理由:**

- 既存の動作するコード（SSR対応、Vuetify連携）を活用
- 段階的な移行により、リスクを最小化
- 開発者にとって使いやすい統一API

### 学んだ教訓

#### KEY INSIGHT: 段階的統一化パターンの有効性

- **既存資産の価値**: 動作している既存コードは貴重な資産として活用すべき
- **上位レイヤーでの統一**: 下位の実装を変更せずに、使いやすいAPIを提供可能
- **段階的アプローチ**: 一度にすべてを変更するよりも安全で効率的

#### UI状態管理のベストプラクティス

1. **グローバル状態の一元管理**: アプリケーション全体で一貫したUI状態管理
2. **共通コンポーネントの活用**: `AppSnackbar`、`AppProgress`をレイアウトに配置
3. **型安全性の確保**: 明示的な戻り値型定義とlinterエラーの完全解消

#### 開発者体験の向上

```typescript
// 統一前: 複数のcomposableを覚える必要
const snackbar = useSnackbar();
const progress = useProgress();
snackbar.showSuccess('成功');
progress.show({ text: '処理中...' });

// 統一後: 一つのAPIで完結
const ui = useUIState();
ui.showSuccess('成功');
ui.showLoading({ message: '処理中...' });
```

### 関連タスク

- TPC-101: ユーザーダッシュボードの実装
- 共通UIコンポーネントの実装と統一化

### 今後の適用可能性

- 他のUI状態（モーダル、サイドバー、トースト通知など）への拡張
- 他のアプリケーション（api-backend、line-bot）での類似パターンの適用
- アニメーションやテーマの統一化

## Nuxt 3 + VuetifyでのSSR/SPAハイブリッド構成の課題と解決策 (2025-01-27)

### 背景と課題

- Nuxt 3でSSG（静的サイト生成）とSPA（シングルページアプリケーション）を組み合わせたハイブリッド構成を実装
- パブリックページ（LP）はSSG、アプリページ（/app/**）はSPAとして動作させる必要があった
- 以下の問題が発生：
  1. PC表示時にVuetifyのサイドバーがフッターの上に表示される
  2. SPAルートでのリロード時に404エラーが発生
  3. SSRハイドレーション時のスタイル不整合警告
  4. エラーページでのナビゲーション不具合

### 検討したアプローチ

#### 1. サイドバー表示問題

- **アプローチA**: CSSでz-indexを調整
- **アプローチB**: Vuetifyの`app`プロパティを使用
- **選択**: アプローチB - Vuetifyのアプリケーションレイアウトシステムを正しく活用

#### 2. SPAルートの404問題

- **アプローチA**: 完全SPAモード（`ssr: false`）
- **アプローチB**: routeRulesでルート別制御
- **アプローチC**: カスタムミドルウェアとプラグイン
- **選択**: アプローチB + C - routeRulesとフォールバック処理の組み合わせ

#### 3. SSRハイドレーション問題

- **アプローチA**: ClientOnlyコンポーネントでラップ
- **アプローチB**: Vuetify設定の調整
- **アプローチC**: experimental.payloadExtraction無効化
- **選択**: 全てのアプローチを組み合わせ

### 決定事項と理由

#### 1. Vuetifyナビゲーションドロワー設定

```typescript
// vuetify.ts
defaults: {
  VNavigationDrawer: {
    temporary: false,
    permanent: true,
  },
}
```

- **理由**: SSRとクライアントサイドでの一貫した動作を保証

#### 2. ハイブリッドレンダリング戦略

```typescript
// nuxt.config.ts
routeRules: {
  '/': { prerender: true },                    // LP: SSG
  '/headline-topic-programs/**': { prerender: true }, // コンテンツ: SSG
  '/app/**': { ssr: false },                   // アプリ: SPA
}
```

- **理由**: SEOが重要なページはSSG、インタラクティブなアプリはSPAで最適化

#### 3. SSGビルドでのSPAフォールバック

```typescript
// nitro hooks内で200.htmlを生成
fs.copyFileSync(indexPath, fallbackPath);
```

- **理由**: 静的ホスティングでのSPAルーティングサポート

#### 4. ClientOnlyラッピング

```vue
<ClientOnly>
  <v-navigation-drawer>
  <!-- ... -->
  </v-navigation-drawer>
</ClientOnly>
```

- **理由**: SSRハイドレーション問題の根本的解決

### 学んだ教訓

#### KEY INSIGHT: Nuxt 3でのハイブリッドレンダリング

1. **routeRulesは強力だが、開発環境と本番環境で動作が異なる**
   - 開発サーバーでは完全な制御が困難
   - SSGビルドでは追加のフォールバック設定が必要

2. **Vuetifyコンポーネントのハイドレーション問題**
   - z-indexなどの動的スタイルでSSR/クライアント間の不整合が発生
   - ClientOnlyラッピングが最も確実な解決策

3. **エラーハンドリングの複雑性**
   - SSGとSPAの混在環境では、エラーページのナビゲーション処理が複雑
   - シンプルなフォールバック（ホームに戻る）が最も確実

#### GLOBAL LEARNING: SPAフォールバック実装パターン

```typescript
// 1. 200.html生成（静的ホスティング用）
// 2. クライアントサイドルーティング処理
// 3. ミドルウェアでの存在しないルート処理
```

### 残された課題と今後の改善点

1. **パフォーマンス最適化**
   - ClientOnlyコンポーネントによる初期レンダリング遅延
   - より効率的なハイドレーション戦略の検討

2. **開発体験の改善**
   - 開発サーバーでのSPAルート処理の安定化
   - ホットリロード時の状態保持

3. **エラーハンドリングの拡張**
   - SPAルート専用のエラーページ
   - より詳細なエラー情報の提供

### 関連タスク

- lp-frontend レイアウト修正
- Nuxt 3 SSG/SPA ハイブリッド構成
- Vuetify SSRハイドレーション問題解決

## リアルタイムバリデーション機能の実装と最適化 (2025-05-30)

### 背景と課題

パーソナルフィード管理画面において、ユーザーの入力ミスを事前に防ぎ、より良いユーザー体験を提供するためのリアルタイムバリデーション機能の実装が必要だった。既存のシンプルなバリデーションから、詳細で分かりやすいフィードバックを提供するシステムへの拡張。

### 検討したアプローチ

1. **即座のバリデーション**: 入力と同時にバリデーションを実行
   - 利点: 即座のフィードバック
   - 欠点: パフォーマンス負荷、ユーザーの入力を妨げる可能性
2. **デバウンス付きリアルタイムバリデーション**: 入力停止後一定時間でバリデーション実行
   - 利点: パフォーマンスとユーザビリティのバランス
   - 欠点: 若干の遅延
3. **フォーカス離脱時バリデーション**: フィールドからフォーカスが外れた時のみ実行
   - 利点: パフォーマンス負荷が少ない
   - 欠点: フィードバックが遅い

### 決定事項と理由

**デバウンス付きリアルタイムバリデーション（500ms）を採用**

- ユーザーが入力を完了してから適切なタイミングでフィードバックを提供
- パフォーマンス負荷を最小限に抑制
- 入力中の邪魔にならない適切な遅延時間

### 学んだ教訓

#### KEY INSIGHT: デバウンス時間の最適化

- **500msが最適**: ユーザーの入力速度とフィードバックの即時性のバランス
- 短すぎる（200ms以下）: 入力中にバリデーションが頻繁に実行され、パフォーマンス低下
- 長すぎる（1000ms以上）: フィードバックが遅く感じられ、ユーザー体験が悪化

#### KEY INSIGHT: エラーと警告の分離

- **エラー**: 必須項目の未入力、形式不正など、送信を阻害する問題
- **警告**: 推奨設定からの逸脱、最適化の提案など、送信は可能だが改善余地がある項目
- この分離により、ユーザーは重要度に応じて対応を判断可能

#### KEY INSIGHT: プラン別制限値の動的対応

- ハードコードされた制限値ではなく、propsを通じた動的設定により、ビジネス要件の変更に柔軟に対応
- コンポーネントの再利用性と保守性が大幅に向上

#### GLOBAL LEARNING: Vue 3での変数宣言順序

- computedプロパティ内で参照される変数は、computed定義より前に宣言する必要がある
- リアクティブシステムの依存関係を正しく理解することが重要

### 実装パターン

```typescript
// デバウンス付きバリデーション
const { validationResult, isValid, getFieldErrors } = useFeedValidation(feedData, {
  realtime: true,
  debounceDelay: 500,
  maxTags: props.maxTags,
  maxAuthors: props.maxAuthors,
});

// エラーと警告の統合表示
const getFieldErrors = (field: string): string[] => {
  const validationErrors = getValidationFieldErrors(field);
  const propsErrors = props.fieldErrors[field] || [];
  return [...validationErrors, ...propsErrors];
};
```

### 関連タスク

- TPC-101: ユーザーダッシュボードの実装
- パーソナルフィード管理画面のバリデーション機能統合
