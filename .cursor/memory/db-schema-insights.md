# データベーススキーマ設計の洞察と発見

## パーソナルプログラムと記事の関連性 (2023-07-25)

### 初期検討事項と再考

**初期考察:**

- 当初、パーソナルプログラムで紹介する記事には以下の追加情報が必要と考えた:
    - 関連性スコア: 記事とパーソナルフィードの関連度
    - 言及時間情報: プログラム内で記事が言及されたタイムスタンプ
    - 専用の中間テーブル: これらメタデータを保存するための明示的なテーブル

**再考後の結論:**

- 既存のテーブル構成（`QiitaPost`と`PersonalizedFeedProgram`の多対多関連）で十分
- パーソナルフィード条件（著者、タグ、いいね数、公開日範囲）に基づいて記事が選別されるため、関連性スコアは不要
- 言及時間はプログラム生成日時（`createdAt`）で代用可能
- Prismaの自動生成される中間テーブルで十分であり、明示的な中間テーブルは不要

### 学んだ教訓

1. **機能要件の正確な理解の重要性:**
   - データモデルを設計する前に、実際の機能要件と利用パターンを深く理解することが重要
   - 単に「こういうデータがあるべき」ではなく「このデータがどう使われるか」を考慮する

2. **既存の構造の活用:**
   - 新しいテーブルやカラムを追加する前に、既存のデータ構造で要件を満たせないか検討する
   - 多対多関連などのORM機能を活用することで、明示的な中間テーブルが不要になる場合も多い

3. **過剰設計の回避:**
   - 「将来必要かもしれない」という理由だけでデータモデルを複雑化しない
   - 実際に必要になった時点で拡張することも選択肢として考慮する

## 今後のデータモデル変更時の注意点

1. **要件確認のチェックリスト:**
   - そのデータは実際にどのように使用されるか？
   - 既存のモデルで満たせないか？
   - 性能への影響は？（新しいインデックスやテーブルが必要か）
   - 既存データとの互換性は？（マイグレーション戦略）

2. **マイグレーション計画:**
   - 必ずテスト環境でマイグレーションをテスト
   - 本番データへの影響を最小限にする戦略を立てる
   - ロールバック計画を必ず用意する

## パーソナルプログラム×記事の多対多関連活用パターン (2025-05-07)

### 背景と課題

パーソナルプログラム（ユーザー向け生成コンテンツ）で紹介されたQiita記事情報を永続化し、ユーザーが後から参照できるようにする機能の設計が必要だった。記事とプログラムの関連を効率的に保存し、将来の検索や取得を容易にする構造が求められた。

### 検討したアプローチ

1. **専用の中間テーブル設計**:
    - 記事とプログラムの関連性スコア、言及時間などの詳細情報を含む独自の中間テーブル
    - メリット: よりリッチな情報を保持可能
    - デメリット: 追加のテーブルとマイグレーションが必要、複雑性の増加

2. **既存の多対多関連の活用**:
    - Prismaの自動生成される多対多関連テーブルを使用
    - メリット: シンプル、追加のマイグレーション不要、管理が容易
    - デメリット: 保存できるメタデータが限定的

### 決定事項と理由

- 既存の多対多関連を活用する設計を採用
- 理由:
  1. 現在のユースケースでは関連性の有無を記録できれば十分
  2. 多対多関連はPrismaによって適切に管理される
  3. HeadlineTopicProgramとのデータ構造の一貫性維持
  4. スキーマ変更リスクの排除

### スキーマデザインのポイント

- **QiitaPost**モデル: 記事の基本情報（ID、タイトル、URL、著者など）を保持
- **PersonalizedFeedProgram**モデル: 生成されたプログラム情報を保持
- **多対多関連**: `PersonalizedFeedProgram.posts` と `QiitaPost.personalizedPrograms` で双方向の関連付け
- **トランザクション**: 記事の登録とプログラムとの関連付けを1つのトランザクションで処理
- **クエリ最適化**: プログラムの取得時に関連記事を一緒にロード（`include: { posts: true }`）

### 学んだ教訓

1. データモデル設計では、最小限の複雑さで現在の要件を満たすことを優先すべき
2. Prismaの多対多関連機能を活用することで、中間テーブルの詳細実装を抽象化できる
3. 既存のデータ構造との一貫性は、将来のコードメンテナンスと拡張性に貢献する
4. ユーザー体験を向上させるために必要な情報に絞りデータベース設計をシンプルに保つ
5. 将来の拡張性を考慮しつつも、過度な設計の複雑化は避ける

### 関連タスク

- 紹介記事テーブル設計 (P0)
- 記事データ保存プロセス実装 (P1)
- ユーザー記事履歴API実装（予定）

## パーソナルプログラム記事データ永続化の設計 (2024-03-21)

### 背景と課題

- パーソナルプログラムで紹介されたQiita記事の情報を永続化する必要があった
- ユーザーが過去に紹介された記事を参照できるようにする必要があった
- 既存のデータベース構造を最大限活用する必要があった

### 検討したアプローチ

1. **新規テーブル作成アプローチ**
   - 利点：
     - 完全に新しい要件に特化した設計が可能
     - 関連性スコアや言及時間などの追加情報を柔軟に保存可能
   - 欠点：
     - 既存のテーブルとの重複が発生
     - マイグレーションコストが高い
     - データの整合性維持が複雑になる

2. **既存テーブル活用アプローチ**
   - 利点：
     - 既存のQiitaPostモデルとPersonalizedFeedProgramの多対多関連を活用可能
     - マイグレーションが不要
     - データの整合性が保ちやすい
   - 欠点：
     - 追加情報の保存に制限がある
     - 既存のテーブル構造に依存する

### 決定事項と理由

- 既存のテーブル構造を活用するアプローチを採用
- 理由：
  1. QiitaPostモデルに必要な基本情報（ID、タイトル、URL、著者など）がすでに含まれている
  2. PersonalizedFeedProgramとQiitaPostの多対多関連で記事とプログラムの紐付けが可能
  3. パーソナルフィードの条件に基づいて記事が選別されるため、関連性スコアは不要
  4. 言及時間はプログラム生成日時で代用可能

### 学んだ教訓

1. **既存のデータベース構造の再評価**
   - 新機能追加時は、まず既存のテーブル構造で要件を満たせるか検討すべき
   - 不要なテーブル追加を避けることで、システムの複雑性を抑制できる

2. **多対多関連の活用**
   - 中間テーブルを活用することで、柔軟な関連付けが可能
   - 自動生成される中間テーブルで十分な場合が多い

3. **データの重複回避**
   - 同じ情報を複数のテーブルに保存することを避ける
   - 既存のデータを最大限活用することで、整合性を保ちやすい

### 関連タスク

- パーソナルプログラム記事データ永続化タスク
- ユーザー記事履歴API実装タスク
- 記事履歴表示UI実装タスク

### KEY INSIGHT

- 新機能追加時は、既存のデータベース構造を最大限活用することを優先すべき
- 不要なテーブル追加は避け、既存の関連を活用することで、システムの複雑性を抑制できる

## AppUserテーブル拡張によるユーザー設定管理 (2025-05-27)

### 背景と課題

TPC-101でユーザー設定機能を実装するため、既存のAppUserテーブルの拡張を検討。主な課題：

- 既存データとの整合性維持
- 将来的な設定項目拡張への対応
- モノレポ環境での影響範囲管理
- パフォーマンスへの影響最小化

### 検討したアプローチ

#### 1. データモデル設計

**選択肢A**: 新しいUserSettingsテーブル作成

```sql
CREATE TABLE UserSettings (
  id UUID PRIMARY KEY,
  userId VARCHAR(255) REFERENCES AppUser(id),
  slackWebhookUrl VARCHAR(500),
  notificationEnabled BOOLEAN DEFAULT false,
  createdAt TIMESTAMP DEFAULT NOW(),
  updatedAt TIMESTAMP DEFAULT NOW()
);
```

- 利点: 関心の分離、正規化、拡張性
- 欠点: JOIN処理、複雑性増加、パフォーマンス影響

**選択肢B**: AppUserテーブル拡張

```sql
ALTER TABLE AppUser
ADD COLUMN slackWebhookUrl VARCHAR(500),
ADD COLUMN notificationEnabled BOOLEAN DEFAULT false;
```

- 利点: シンプル、パフォーマンス、既存コードとの親和性
- 欠点: テーブル肥大化、関心の混在

#### 2. フィールド設計

**slackWebhookUrl**:

- 型: VARCHAR(500) - Slack URLの最大長を考慮
- NULL許可: 設定が任意のため
- バリデーション: アプリケーション層で実装

**notificationEnabled**:

- 型: BOOLEAN
- デフォルト: false - セキュリティ重視（オプトイン）
- NOT NULL: 明確な状態管理

### 決定事項と理由

#### 1. AppUserテーブル拡張を採用

- **理由**: ユーザー設定は基本的なユーザー属性
- **パフォーマンス**: 頻繁なアクセスでJOIN回避
- **シンプル性**: 既存のユーザー管理ロジックとの統合

#### 2. マイグレーション戦略

```sql
-- Migration: 20250527025712_add_user_settings
ALTER TABLE "AppUser"
ADD COLUMN "slackWebhookUrl" VARCHAR(500),
ADD COLUMN "notificationEnabled" BOOLEAN NOT NULL DEFAULT false;
```

#### 3. インデックス戦略

- 現時点では追加インデックス不要
- 将来的な検索要件に応じて検討

### 学んだ教訓

#### KEY INSIGHT: モノレポでのスキーマ変更影響管理

- **影響範囲**: 複数アプリケーションのモデル定義
- **対策**: 段階的なマイグレーション、テスト確認
- **チェックポイント**:
    - `packages/database/prisma/schema.prisma`
    - `apps/api-backend/src/test/factories/`
    - `apps/backend/src/test/factories/`

#### KEY INSIGHT: デフォルト値の重要性

- **notificationEnabled**: デフォルトfalse
- **理由**: プライバシー保護、GDPR準拠
- **効果**: ユーザーの明示的な同意が必要

#### KEY INSIGHT: フィールド長の設計

- **slackWebhookUrl**: VARCHAR(500)
- **根拠**: Slack Webhook URLの実際の長さ調査
- **余裕**: 将来的なURL形式変更への対応

#### GLOBAL LEARNING: 段階的マイグレーション戦略

1. **スキーマ定義更新**
2. **マイグレーション生成**
3. **マイグレーション適用**
4. **アプリケーションコード更新**
5. **テスト修正**
6. **統合確認**

### 技術的発見

#### 1. Prismaスキーマ設計パターン

```prisma
model AppUser {
  id                     String   @id
  // ... 既存フィールド
  slackWebhookUrl        String?  @db.VarChar(500)
  notificationEnabled    Boolean  @default(false)
  // ... 他のフィールド
}
```

#### 2. マイグレーション命名規則

- フォーマット: `YYYYMMDDHHMMSS_description`
- 例: `20250527025712_add_user_settings`
- 利点: 時系列順序、内容の明確化

#### 3. NULL vs デフォルト値の使い分け

- **NULL許可**: 任意設定（slackWebhookUrl）
- **デフォルト値**: 必須だが初期値がある（notificationEnabled）

### パフォーマンス考慮

#### 1. クエリパフォーマンス

- **SELECT**: 追加フィールドによる影響は軽微
- **UPDATE**: 部分更新で最適化
- **インデックス**: 現時点では不要

#### 2. ストレージ効率

- **VARCHAR(500)**: 実際の使用量に応じて可変長
- **BOOLEAN**: 1バイト、効率的

### 将来の拡張性

#### 1. 設定項目の追加

- **アプローチ**: 個別フィールド vs JSON型
- **推奨**: 構造化された設定はフィールド、柔軟な設定はJSON

#### 2. 設定履歴の管理

- **課題**: 設定変更の監査ログ
- **提案**: 別テーブルでの履歴管理

#### 3. 設定のカテゴリ化

- **課題**: 設定項目の増加
- **提案**: 設定グループの概念導入

### 残された課題と改善点

#### 1. 設定値のバリデーション

- **課題**: データベースレベルでのバリデーション不足
- **提案**: CHECK制約の追加検討

#### 2. 設定の暗号化

- **課題**: 機密性の高い設定値の保護
- **提案**: アプリケーション層での暗号化

#### 3. 設定のバックアップ

- **課題**: ユーザー設定の復旧機能
- **提案**: 定期的なバックアップ戦略

### 関連タスク

- TPC-101: ユーザー設定取得/更新API実装
- 将来タスク: 設定履歴管理、設定暗号化、バックアップ機能

### メタデータ

- **データベース**: PostgreSQL
- **ORM**: Prisma
- **マイグレーション**: Prisma Migrate
- **テーブル**: AppUser拡張

## PersonalizedFeed テーブルへの SpeakerMode 追加 (2025-06-14)

### 背景と課題

TPC-125「複数話者での記事解説に対応する」機能実装のため、PersonalizedFeedテーブルに話者モード（単一話者/複数話者）を選択できるフィールドを追加する必要があった。

### 検討したアプローチ

1. **ENUMタイプの使用**: `SpeakerMode` ENUMを新規作成し、`SINGLE`と`MULTI`の値を定義
2. **既存テーブルへのカラム追加**: `PersonalizedFeed`テーブルに`speakerMode`フィールドを追加
3. **デフォルト値の設定**: 既存データとの互換性を保つため、デフォルト値を`SINGLE`に設定

### 決定事項と理由

- **ENUMタイプ採用**: 型安全性と可読性を重視し、`SpeakerMode` ENUMを作成
- **デフォルト値**: 既存の1人解説機能との互換性を保つため`SINGLE`をデフォルトに設定
- **カラム名**: `speaker_mode`（スネークケース）でデータベースに格納、Prismaでは`speakerMode`（キャメルケース）でマッピング

### 学んだ教訓 - KEY INSIGHT

**プロジェクト固有のワークフロー遵守の重要性**:

- ユーザーから「yarnを使用する」「Prismaスクリプトはルートのpackage.jsonに準備済み」という指示を**複数回**受けた
- 初回の作業で適切なスクリプトを確認せず、間違ったコマンドを提案してしまった
- **教訓**: 新しいプロジェクトでは必ず最初にpackage.jsonのscriptsセクションを確認し、プロジェクト固有のワークフローを把握する

**正しいPrismaワークフロー**:

1. `yarn format-prisma` - スキーマファイルのフォーマット
2. `yarn generate-prisma` - Prismaクライアントの再生成
3. `yarn create-migration-prisma` - マイグレーションファイルの作成
4. `yarn deploy-migration-prisma` - マイグレーションの適用

### 実装詳細

```sql
-- 作成されたマイグレーション内容
CREATE TYPE "SpeakerMode" AS ENUM ('SINGLE', 'MULTI');
ALTER TABLE "personalized_feeds" ADD COLUMN "speaker_mode" "SpeakerMode" NOT NULL DEFAULT 'SINGLE';
```

```prisma
// Prismaスキーマ追加内容
enum SpeakerMode {
  SINGLE  // 単一話者（ポステル）による解説
  MULTI   // 複数話者（ポステル + ジョン）による対話形式解説
}

model PersonalizedFeed {
  // ... 既存フィールド
  speakerMode SpeakerMode @default(SINGLE) @map("speaker_mode")
  // ... 既存フィールド
}
```

### 関連タスク

- TPC-125: 複数話者での記事解説に対応する
- Phase 1: データベース・API基盤（完了: スキーマ変更、マイグレーション作成・適用）

### 次のステップへの示唆

- API Backend のDTO更新時も、プロジェクト固有の命名規則やパターンを事前確認する
- 既存のPersonalizedFeed関連のDTO構造を把握してから変更を実施する
