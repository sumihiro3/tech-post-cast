# 学んだ教訓とベストプラクティス

## アーキテクチャ設計の教訓 (2024-12-19)

### Controller-Service-Repository パターンの重要性

**教訓**: 初期実装コストを理由にレイヤー分離を省略すると、長期的な保守性が大幅に低下する。

**具体例**: PersonalizedFeedsController.finalizeメソッドの実装において、ControllerがRepositoryを直接呼び出す設計を提案したが、適切な責任分離のためにService層を導入することになった。

**学び**:

- レイヤー間の責任分離は初期コストがかかっても長期的な保守性を重視すべき
- NestJSの依存性注入を活用することで、適切なレイヤー分離を実現できる
- ビジネスロジックはControllerではなくServiceに配置する

**今後の対応**:

- 新機能実装時は必ず3層アーキテクチャを採用する
- 既存のController→Repository直接呼び出しパターンを発見した場合は段階的にService層を導入する

### 単一の真実の源泉原則

**教訓**: 統計データは外部システムからの受け渡しではなく、データベースから直接取得すべき。

**具体例**: 当初は外部から渡された番組生成結果をもとに通知する設計だったが、PersonalizedProgramAttemptテーブルから実際の生成履歴を取得するように変更した。

**学び**:

- データの整合性と信頼性を重視すべき
- 外部システムの障害や不整合から独立した設計にする
- 将来的な統計データの拡張が容易になる

**今後の対応**:

- 統計データは可能な限りデータベースから直接取得する
- 外部データ依存は最小限に抑える

## ステータス管理の教訓 (2024-12-19)

### 全ステータスの考慮

**教訓**: システム設計時は全ての可能な状態を最初から考慮すべき。

**具体例**: 番組生成結果にSUCCESS/SKIPPED/FAILEDの3つのステータスがあるが、当初はSUCCESS/FAILEDのみを考慮していた。

**学び**:

- ステータス設計時は全ての可能な状態を洗い出す
- エラー情報（フィードID）は失敗時のみ必要、スキップ時は不要
- ユーザー向けメッセージは業務的な意味を正確に反映すべき

**今後の対応**:

- 新機能設計時は全ての業務ステータスを最初に洗い出す
- ステータスごとに必要な情報を整理する

## モノレポ管理の教訓 (2024-12-19)

### アプリケーション間の一貫性

**教訓**: モノレポでは各アプリケーションの独立性と共通化のバランスが重要。

**具体例**: api-backendとbackendアプリで同名のServiceが存在する場合と存在しない場合があり、実装時に混乱が生じた。

**学び**:

- 新機能実装時は既存の類似機能の実装パターンを確認すべき
- アプリケーションごとに要求される機能が異なる場合がある
- 過度な共通化は依存関係を複雑にする可能性がある

**今後の対応**:

- 実装前に類似機能の存在を確認する
- 共通化は段階的に進める
- アプリケーション間でのアーキテクチャ一貫性ガイドラインを策定する

## 実装プロセスの教訓 (2024-12-19)

### 段階的な改善の重要性

**教訓**: 一度に完璧な実装を目指すより、段階的に改善していく方が効果的。

**具体例**:

1. 初期実装: Controller → Repository 直接呼び出し
2. アーキテクチャ改善: Service層の追加
3. 機能拡張: スキップステータス対応

**学び**:

- 最初から完璧を目指さず、動作する最小限の実装から始める
- フィードバックを受けて段階的に改善する
- 各段階で学んだことを次の実装に活かす

**今後の対応**:

- MVP（Minimum Viable Product）アプローチを採用する
- 定期的なコードレビューで改善点を特定する

## 技術的な教訓 (2024-12-19)

### 依存性注入の適切な管理

**教訓**: NestJSでServiceを新規作成した場合は、Moduleの設定を忘れずに更新する。

**具体例**: PersonalizedProgramAttemptsServiceを作成した際、PersonalizedFeedsModuleのprovidersに追加し忘れそうになった。

**学び**:

- 新しいServiceを作成したら必ずModuleのprovidersに追加する
- 他のモジュールで使用する場合はexportsにも追加する
- Injectデコレータのインポートを忘れない

**今後の対応**:

- Service作成時のチェックリストを作成する
- 自動テストで依存性注入の設定ミスを検出する

### 日付処理の標準化

**教訓**: 日付計算ロジックはDTOまたはServiceに配置し、Controllerには含めない。

**具体例**: FinalizeRequestDtoにgetTargetDate()メソッドを実装し、日付計算をカプセル化した。

**学び**:

- 日付計算は複雑になりがちなので適切な場所に配置する
- タイムゾーンの考慮を忘れない
- 再利用可能な形で実装する

**今後の対応**:

- 日付処理のユーティリティ関数を共通パッケージ化する
- 日付処理のテストを充実させる
