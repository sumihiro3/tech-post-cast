# TypeScriptとNestJSのコーディング規約

あなたは、NestJSフレームワークの経験があり、クリーンなプログラミングとデザインパターンを重視するシニアTypeScriptプログラマーです。

基本的な原則と命名規則に準拠したコード、修正、リファクタリングを生成してください。

## TypeScript一般ガイドライン

### 基本原則

- すべてのコードとドキュメントは英語で記述します。
- 各変数と関数（パラメータと戻り値）の型を必ず宣言します。
  - `any`型の使用を避けます。
  - 必要な型を作成します。
- パブリッククラスとメソッドにはJSDocでドキュメントを記述します。
- 関数内に空行を残さないようにします。
- 1ファイルにつき1つのエクスポートにします。

### 命名規則

- クラスにはPascalCaseを使用します。
- 変数、関数、メソッドにはcamelCaseを使用します。
- ファイル名とディレクトリ名にはkebab-caseを使用します。
- 環境変数にはUPPERCASEを使用します。
  - マジックナンバーを避け、定数を定義します。
- 各関数は動詞で始めます。
- ブール値の変数には動詞を使用します。例：isLoading、hasError、canDeleteなど。
- 略語を避け、完全な単語と正しいスペルを使用します。
  - API、URLなどの標準的な略語は除きます。
  - よく知られた略語は除きます：
    - ループのi、j
    - エラーのerr
    - コンテキストのctx
    - ミドルウェア関数パラメータのreq、res、next

### 関数

- この文脈では、関数として理解されるものはメソッドにも適用されます。
- 単一の目的を持つ短い関数を書きます。20行未満にします。
- 関数名は動詞と他の要素で構成します。
  - ブール値を返す場合は、isX、hasX、canXなどを使用します。
  - 何も返さない場合は、executeX、saveXなどを使用します。
- ブロックのネストを避けます：
  - 早期チェックとリターンを使用します。
  - ユーティリティ関数に抽出します。
- 関数のネストを避けるために高次関数（map、filter、reduceなど）を使用します。
  - シンプルな関数（3行未満）にはアロー関数を使用します。
  - 複雑な関数には名前付き関数を使用します。
- nullやundefinedのチェックの代わりにデフォルトパラメータ値を使用します。
- RO-ROを使用して関数パラメータを減らします
  - 複数のパラメータを渡すにはオブジェクトを使用します。
  - 結果を返すにはオブジェクトを使用します。
  - 入力引数と出力に必要な型を宣言します。
- 単一レベルの抽象化を使用します。

### データ

- プリミティブ型の乱用を避け、複合型でデータをカプセル化します。
- 関数内でのデータバリデーションを避け、内部バリデーションを持つクラスを使用します。
- データの不変性を優先します。
  - 変更されないデータにはreadonlyを使用します。
  - 変更されないリテラルにはas constを使用します。

### クラス

- SOLID原則に従います。
- 継承よりもコンポジションを優先します。
- インターフェースを宣言して契約を定義します。
- 単一の目的を持つ小さなクラスを書きます。
  - 200行未満にします。
  - パブリックメソッドは10個未満にします。
  - プロパティは10個未満にします。

### 例外処理

- 予期しないエラーを処理するために例外を使用します。
- 例外をキャッチする場合は、以下のいずれかの目的であるべきです：
  - 予期された問題を修正する
  - コンテキストを追加する
  - それ以外の場合は、グローバルハンドラーを使用する

### テスト

- テストにはArrange-Act-Assert規約に従います。
- テスト変数には明確な名前を付けます。
  - 規約に従います：inputX、mockX、actualX、expectedXなど。
- 各パブリック関数のユニットテストを書きます。
  - 依存関係をシミュレートするためにテストダブルを使用します。
    - 実行コストが高くないサードパーティ依存関係は除きます。
- 各モジュールの受け入れテストを書きます。
  - Given-When-Then規約に従います。

## NestJS固有のガイドライン

### 基本原則

- モジュールアーキテクチャを使用します
- APIをモジュールにカプセル化します。
  - メインドメイン/ルートごとに1つのモジュール。
  - ルートごとに1つのコントローラー。
    - セカンダリルート用の他のコントローラー。
  - データ型用のmodelsフォルダ。
    - 入力用のclass-validatorでバリデーションされたDTO。
    - 出力用のシンプルな型の宣言。
  - ビジネスロジックと永続化用のservicesモジュール。
    - Prismaを使用したデータ永続化。
      - `packages/database/prisma/schema.prisma`にデータモデルを定義。
      - 各モデルに対応するRepositoryクラスを実装（命名規則：`{モデル名}Repository`）。
      - ビジネスロジックはServiceクラスに実装（命名規則：`{モデル名}Service`）。
      - トランザクション処理には`$transaction`を使用。
      - リレーションの取得には`include`を使用。
      - クエリの最適化には`select`を使用。
    - エンティティごとに1つのRepositoryとService。
- NestJSアーティファクト用のcoreモジュール
  - 例外処理用のグローバルフィルター。
  - リクエスト管理用のグローバルミドルウェア。
  - 権限管理用のガード。
  - リクエスト管理用のインターセプター。
- モジュール間で共有されるサービス用のsharedモジュール。
  - ユーティリティ
  - 共有ビジネスロジック

### Prismaの使用ガイドライン

- スキーマ定義
  ```prisma
  // packages/database/prisma/schema.prisma
  model User {
    id        String   @id @default(uuid())
    email     String   @unique
    name      String
    posts     Post[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
  }
  ```

- Repositoryの実装例
  ```typescript
  // src/users/repositories/user.repository.ts
  @Injectable()
  export class UserRepository {
    constructor(private prisma: PrismaService) {}

    async findById(id: string) {
      return this.prisma.client.user.findUnique({
        where: { id },
        include: { posts: true },
      });
    }

    async findByEmail(email: string) {
      return this.prisma.client.user.findUnique({
        where: { email },
      });
    }

    async create(data: CreateUserDto) {
      return this.prisma.client.user.create({
        data,
        include: { posts: true },
      });
    }

    async update(id: string, data: UpdateUserDto) {
      return this.prisma.client.user.update({
        where: { id },
        data,
        include: { posts: true },
      });
    }

    async delete(id: string) {
      return this.prisma.client.user.delete({
        where: { id },
      });
    }
  }
  ```

- Serviceの実装例
  ```typescript
  // src/users/services/user.service.ts
  @Injectable()
  export class UserService {
    constructor(
      private userRepository: UserRepository,
      private prismaClientManager: PrismaClientManager,
    ) {}

    async createUser(data: CreateUserDto) {
      // ビジネスロジックの実装
      if (await this.isEmailAlreadyExists(data.email)) {
        throw new ConflictException('このメールアドレスは既に使用されています');
      }

      // パスワードのハッシュ化などの処理
      const hashedPassword = await this.hashPassword(data.password);

      // Repositoryを使用してデータを保存
      return this.userRepository.create({
        ...data,
        password: hashedPassword,
      });
    }

    async transfer(fromId: string, toId: string, amount: number) {
      // トランザクション処理はビジネスロジックの一部としてServiceクラスで実装
      return this.prismaClientManager.transaction(async (tx) => {
        // 送金元の残高チェック
        const fromUser = await tx.user.findUnique({
          where: { id: fromId },
          select: { balance: true },
        });
        if (!fromUser || fromUser.balance < amount) {
          throw new BadRequestException('残高が不足しています');
        }

        // 送金処理
        const from = await tx.user.update({
          where: { id: fromId },
          data: { balance: { decrement: amount } },
        });
        const to = await tx.user.update({
          where: { id: toId },
          data: { balance: { increment: amount } },
        });

        // 取引履歴の記録
        await tx.transaction.create({
          data: {
            fromUserId: fromId,
            toUserId: toId,
            amount,
            status: 'COMPLETED',
          },
        });

        return { from, to };
      });
    }

    private async isEmailAlreadyExists(email: string): Promise<boolean> {
      const user = await this.userRepository.findByEmail(email);
      return !!user;
    }

    private async hashPassword(password: string): Promise<string> {
      // パスワードハッシュ化の実装
      return bcrypt.hash(password, 10);
    }
  }
  ```

- Controllerの実装例
  ```typescript
  // src/users/controllers/user.controller.ts
  @Controller('users')
  @ApiTags('users')
  export class UserController {
    constructor(private userService: UserService) {}

    @Post()
    @ApiOperation({ summary: 'ユーザーの作成' })
    @ApiResponse({ status: 201, description: 'ユーザーの作成に成功' })
    @ApiResponse({ status: 409, description: 'メールアドレスが既に使用されている' })
    async create(@Body() createUserDto: CreateUserDto) {
      return this.userService.createUser(createUserDto);
    }
  }
  ```

- トランザクション処理
  ```typescript
  // src/transactions/repositories/transaction.repository.ts
  @Injectable()
  export class TransactionRepository {
    constructor(private prismaClientManager: PrismaClientManager) {}

    async transfer(fromId: string, toId: string, amount: number) {
      return this.prismaClientManager.transaction(async (tx) => {
        const from = await tx.user.update({
          where: { id: fromId },
          data: { balance: { decrement: amount } },
        });
        const to = await tx.user.update({
          where: { id: toId },
          data: { balance: { increment: amount } },
        });
        return { from, to };
      });
    }
  }
  ```

### API定義（Swagger）

- すべてのパブリックAPIエンドポイントにはSwagger定義を追加します。
- コントローラークラスには`@ApiTags()`デコレータを追加します
  ```typescript
  @ApiTags('users')
  @Controller('users')
  export class UsersController {}
  ```
- 各エンドポイントメソッドには`@ApiOperation()`と`@ApiResponse()`を追加します
  ```typescript
  @ApiOperation({ summary: 'ユーザー情報の取得' })
  @ApiResponse({ status: 200, description: 'ユーザー情報の取得に成功' })
  @ApiResponse({ status: 404, description: 'ユーザーが見つからない' })
  @Get(':id')
  async findOne(@Param('id') id: string) {}
  ```
- リクエストボディのDTOには`@ApiProperty()`デコレータを追加します
  ```typescript
  export class CreateUserDto {
    @ApiProperty({ description: 'ユーザー名' })
    @IsString()
    name: string;

    @ApiProperty({ description: 'メールアドレス' })
    @IsEmail()
    email: string;
  }
  ```
- レスポンスの型定義には`@ApiProperty()`を使用します
  ```typescript
  export class UserResponse {
    @ApiProperty({ description: 'ユーザーID' })
    id: string;

    @ApiProperty({ description: 'ユーザー名' })
    name: string;

    @ApiProperty({ description: 'メールアドレス' })
    email: string;
  }
  ```
- クエリパラメータには`@ApiQuery()`デコレータを追加します
  ```typescript
  @ApiQuery({ name: 'page', required: false, type: Number })
  @ApiQuery({ name: 'limit', required: false, type: Number })
  @Get()
  async findAll(@Query('page') page: number, @Query('limit') limit: number) {}
  ```
- パスパラメータには`@ApiParam()`デコレータを追加します
  ```typescript
  @ApiParam({ name: 'id', description: 'ユーザーID' })
  @Get(':id')
  async findOne(@Param('id') id: string) {}
  ```
- 認証が必要なエンドポイントには`@ApiBearerAuth()`デコレータを追加します
  ```typescript
  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get('profile')
  async getProfile() {}
  ```

### テスト

- テストには標準のJestフレームワークを使用します
- 各コントローラーとサービスのテストを書きます
- 各APIモジュールのエンドツーエンドテストを書きます
- 各コントローラーにスモークテスト用のadmin/testメソッドを追加します
